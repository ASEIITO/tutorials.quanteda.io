---
title: Multiple text files
weight: 20
chapter: false
draft: false
---

```{r, message=FALSE}
knitr::opts_chunk$set(collapse = TRUE)
require(quanteda)

# Load the readtext package
require(readtext)

# Get the data directory from readtext
data_dir <- system.file("extdata/", package = "readtext")
```

## Plain text files (.txt)

The folder "txt" contains a subfolder named UDHR with .txt files of the Universal Declaration of Human Rights in 13 languages. 

```{r}
# Read in all files from a folder
readtext(paste0(data_dir, "/txt/UDHR/*"))
```

We can specify document-level metadata (`docvars`) based on the file names or on a separate data.frame. Below we take the docvars from the filenames (`docvarsfrom = "filenames"`) and set the names for each variable (`docvarnames = c("unit", "context", "year", "language", "party")`). The command `dvsep = "_"` determines the separator (a regular expression character string) included in the filenames to delimit the `docvar` elements. `encoding = "ISO-8859-1"` specifies the encoding of the text. Below we describe how you can find out how your text is encoded.

```{r}
# Manifestos with docvars from filenames
readtext(paste0(data_dir, "/txt/EU_manifestos/*.txt"),
         docvarsfrom = "filenames", 
         docvarnames = c("unit", "context", "year", "language", "party"),
         dvsep = "_", 
         encoding = "ISO-8859-1")
```

**readtext** can also curse through subdirectories. In our example, the folder `txt/movie_reviews` contains two subfolders (called `neg` and `pos`). We can load all texts included in both folders. 

```{r}
# Recurse through subdirectories
readtext(paste0(data_dir, "/txt/movie_reviews/*"))
```

## Comma- or tab-separated values (.csv, .tab, .tsv)

Read in comma separted values (.csv files) that contain textual data. We determine the `texts` variable in our .csv file as the `text_field`. This is the column that contains the actual text. The other columns of the original csv file (`Year`, `President`, `FirstName`) are by default treated as document-level variables. 

```{r}
# Read in comma-separated values
readtext(paste0(data_dir, "/csv/inaugCorpus.csv"), text_field = "texts")
```

The same procedure applies to tab-separated values.

```{r}
# Read in tab-separated values
readtext(paste0(data_dir, "/tsv/dailsample.tsv"), text_field = "speech")
```

## JSON data (.json)

You can also read .json data. Again you need to specify the `text_field`. 

```{r}
## Read in JSON data
readtext(paste0(data_dir, "/json/inaugural_sample.json"), text_field = "texts")
```

## PDF files

**readtext** can also read in and convert .pdf files. In the example below we load all .pdf files stored in the `UDHR` folder, and determine that the `docvars` shall be taken from the filenames. We call the document-level variables `document` and `language`, and specify the delimiter (`dvsep`).

```{r}
## Read in Universal Declaration of Human Rights pdf files
(rt_pdf <- readtext(paste0(data_dir, "/pdf/UDHR/*.pdf"), 
                    docvarsfrom = "filenames", 
                    docvarnames = c("document", "language"),
                    sep = "_"))
```


## Microsoft Word files (.doc, .docx)

Microsoft Word formatted files are converted through the package **antiword** for older `.doc` files, and using **XML** for newer `.docx` files.

```{r}
## Read in Word data (.docx)
readtext(paste0(data_dir, "/word/*.docx"))
```
